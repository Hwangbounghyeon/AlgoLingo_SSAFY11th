# 달팽이가 이동하는 순서(델타배열)
# 시계방향순으로 순회
di = [0, 1, 0, -1]
dj = [1, 0, -1, 0]

# 테스트 케이스 수 T
T = int(input())
for tc in range(1, T+1):
#입력
    #배열의 한변의 길이
    N = int(input())

    # N * N의 배열을 생성..!
    arr = [[0]* N for _ in range(N)]


#로직
    #반복문 작성. 
    #달팽이가 종료하는 조건은 ? N*N 수치까지!
    cnt = 1 # 달팽이가 작성할 숫자 값
    # 달팽이의 현재 위치 좌표
    i, j = 0, 0
    dr = 0 # 달팽이가 현재 바라보는 방향
    while True:
        # 카운트 값을 1 증가
        if cnt == N* N:
            break
        # 달팽이의 현재 위치에다가 카운트 값을 작성...!
        arr[i][j] = cnt
        # 달팽이 위치 이동
        # 다음 좌표 ni, nj...
        ni = i + di[dr]
        nj = j + dj[dr]
        # 그런데 회전조건이 필요하다
        # 1. 배열 바깥으로 나가려고 할때
        if 0 > ni or N <= ni or 0 > nj or nj >= N:
            # 방향을 시계방향으로 바꿔주고...
            # 오버카운트 된것을 돌리기 위해 cnt를 뺴준다
            cnt -= 1
            dr = (dr + 1) % 4 # 4방향 이후 나가는 것을 방지하기위해 나머지 값으로 방향을 다시 잡아준다
        
        # 2. 해당 위치에 이미 값이 할당된 경우
        if arr[ni][nj] != 0:
            dr = (dr + 1) % 4
            # 오버카운트 된것을 돌리기 위해 cnt를 뺴준다
            cnt -= 1

        # 1과 2 를 합쳐서 전체 or로 묶을 수 있다.
        # 다음 좌표로 이동
        i, j = ni, nj    


    # 출력 방법 2개
    # 1. 일일이 해당 요소를 출력
    # for i in range(N):
    #     for j in range(N):
    #         print(arr[i][j], end = " ")
    #     print(arr[i][N-1]) # 개행
    
    # 2. 언패킹을 사용해서 하나의 행을 한번에 출력
        print(*arr[i])