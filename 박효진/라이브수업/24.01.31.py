# N = int(input())
# arr = [list(map(int, input().split())) for _ in range(N)]
# print(arr)

# arr2 = [[0]*N for _ in range(N)]
# print(arr2)
# arr2[0][0] = 1
# print(arr2)
# # arr3 = [[0]*N]*N
# # print(arr[3])
# # arr3[0][0] = 1
# # print(arr[3])  # << 얕은복사 때문에 하면 안되는 것

# #지그재그 순회
# # i 행의 좌표
# # j 행의 좌표
# for i in range(n):
#     for j in range(m):
#         f(array[i][j + (m-1-2)*(j%2)])

# #부분집합 생성
# bit = [0, 0, 0, 0]
# for i in range(2):
#     bit[0] = i
#     for j in range(2):
#         bit[1] = j
#         for k in range(2):
#             bit[2] = k
#             for l in range(2):
#                 bit[3] = l
#                 print_subset(bit)

# 간결한 부분집합 생성 예시
arr = [3,6,7,1,5,4]
n = len(arr)    # n : 원소의 개수
for i in range(1<<n):
    for j in range(n):
        if i & (1<<j):
            print(arr[j], end = ",")
        print()
    print()


# 부분집합 합 문제 구현하기


'''
2차원 > 1차원 list를 묶어놓은 list 2중첩 리스트
arr이라는 배열안에 리스트 안 리스트를 넣어두는 것
엑셀에 행과 열로써 표현이 가능하다

데이터 입력은 한줄로 되어있으나, 표현은 배열형태로

리스트컴프리헨션을 통해 만든다.
공백을 원한다면 split 사용, 문자열 그대로 받을거면 없이 (input의 타입에 따라 선택)
주로 공백이 들어간 것으로 많이 함

2중for문을 통해 배열 순회를 진행할 것.
# 행(가로) 우선 순회
# i 행의 좌표
# j 열의 좌표
for i in range(n):
    for j in range(m):
        Array[i][j] #필요한 연산 수행

# 열(세로) 우선 순회
# i 행의 좌표
# j 열의 좌표
for j in range(n):
    for i in range(m):
        Array[i][j] #필요한 연산 수행

# 지그재그 순회
# 굳이 멋있게 한번에 쓸 필요없이. if else를 통해 좌 우를 선택해준다.

#델타를 이용한 2차 배열탐색
하나의 표를 찾아가는 배열 탐색
중간 좌표를 정하고 4방향에 대한 좌표를 델타라고한다. 
일단 알아야 하는 것은 di, dj를 통해 좌표를 특정하여 움직일 수 있다.
가장 많이 쓰이는 형태

# 전치 행렬
# i : 행의 좌표, len(arr)
# j : 열의 좌표, len(arr[0])
arr = [[1,2,3],[4,5,6],[7,8,9]] # 3*3 행렬
for i in range(3):
    for j in range(3):
        if i < j:       #만약 if가 없다면 전치가 진행되지 않을 수 있으니 한번 해봐라
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]

연습문제 풀어보는것이 좋다. 싸피에서 가장 좋아하는 문제 유형
(풍선펑 유형)

-----------

부분집합 합 문제(빌드업 문제)

문제. 유한개의 정수로 이루어진 집합에서 부분집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는가?
예를들어 , [-7, -3, -2, 5, 8]에서 [-3, -2, 5]가 되는 것처럼

접근. 우선 모든 집합의 경우의수. 부분집합을 생성한 후에 부분집합의 합을 계산한다.

부분집합을 어떻게 만들것이냐? (2의 N제곱수)
집합안의 요소가 총 4개일 경우 해당 되는 요소의 2의 4제곱 가지가 가능하다.(순서가 상관없기때문)

bit라는 배열을 만들어서 해당되는 비트를 0 or 1로 바꾸겠다는 부분집합 생성
0000 0001 0010 0011 0100 0101 0110 0111 ... 1111 >> 2진법의 규칙으로 총 0부터 15까지 16개 = 2의 4제곱개

비트 연산자
AND : 
      0110 =6
      0101 =5
      ---- 
      0100 =4  >>> 6 & 5 -> 4

OR :  
      0110 =6
      0101 =5
      ----
      0111 =7  >>> 6 | 5 -> 7

<<, >> : 시프트 연산자
         0101 = 5
         <<1    (오른쪽에 0 추가)
         01010 = 10
         <<1    (오른쪽에 0 추가)
         010100 = 20
1<<n은 10진수 기준으로 곱하기 2 한 것임.
파이썬에서 1<<n  과 2 ** n 이 가능 n이 4라면 계산값 둘다 16이 나오게됨


&연산자 : 

j=2 = 10
i=0100
i&(1<<j) 100과 0100에서 같은지 비교

arr = [3, 6, 7, 1, 5, 4]
n = len(arr) # n: 원소의 개수
for i in range(1<<n): # 여기서 1<<n은 위에서 배웠든 부분집합을 만들수 있는 개수 (1<<n=2**n)
    for j in range(n): # 0부터 n-1까지 3,6,7,1,5,4들을 돌고
        if i & (1<<j) # i의 j 비트가 1인 경우
            print(arr[j], end= ", ")
    print()
print()

첫번째 for문 싸이클을 해보면
i = 000000 000001 000010 000011 000100 ... 111111   (총 2의 6제곱 개)

두번째 for문 싸이클을 해보면
j는 해당되는 비트 기준으로 오른쪽부터. j=0일때 1<<j = 1
j=1일때 10
j=2일때 100
j=3일때 1000
...
j=5일때 100000

2진수의 값으로 했을때 마치 해당되는 배열에다가 오른쪽에서 왼쪽으로 이동하는 것처럼 표현할 수 있다.
마치 배열에서 인덱스를 오른쪽에서 왼쪽으로 이동하는 것처럼

여기서 i와 &연산을 진행
j=0일때 1<<j = 1
i가 3이라고 가정하면 000011인데 그러면
                    000001 (j=0인것과 &연산)
if i & (1<<j): 의 Falsy 조건(정수0) 에 의해 참이 된다면 아래의 코드를 실행한다

연습문제2 부분집합 합 문제 구현하기
arr = [1,2,3,4,5,6,7,8,9,-15]로 풀어봐라
'''